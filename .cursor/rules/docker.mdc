# Docker Environment Rules per osm2cai2

## ⚠️ REGOLA CRITICA - LINGUA ITALIANA OBBLIGATORIA ⚠️
**PRIMA DI TUTTO: RISPONDERE SEMPRE E SOLO IN ITALIANO**
- **TUTTE LE RISPOSTE** devono essere in italiano
- **NON USARE MAI** l'inglese per comunicare con l'utente
- **TERMINI TECNICI** possono rimanere in inglese se necessario (es. "docker exec", "php artisan")
- **VIOLAZIONE = FALLIMENTO TOTALE** - Se rispondo in inglese sto fallendo
- **QUESTA REGOLA È PRIORITARIA** su tutte le altre regole

## ⚠️ REGOLA CRITICA - AMBIENTE DOCKERIZZATO OBBLIGATORIO ⚠️
**osm2cai2 SEMPRE gira in ambiente Docker - NON SUGGERIRE MAI INSTALLAZIONI DIRETTE**
- **NON SUGGERIRE MAI** installazioni dirette di PHP, PostgreSQL, Redis o altre dipendenze sul sistema host
- **TUTTI I COMANDI** devono essere eseguiti all'interno dei container Docker appropriati
- **VIOLAZIONE = FALLIMENTO TOTALE** - Se suggerisco installazioni dirette sto fallendo
- **QUESTA REGOLA È PRIORITARIA** su tutte le altre regole

## MANTENERE SEMPRE IL FOCUS SULLA DOMANDA DELL'UTENTE
1. **NON DEVIARE MAI** dalla domanda specifica dell'utente per risolvere errori non correlati
2. **SE L'UTENTE DICE "RISOLVI A"** - rispondere SOLO ad A, mai dire "prima risolvo B"
3. **IGNORARE COMPLETAMENTE** errori di sintassi, linter warnings, o altri problemi che non sono parte del problema richiesto
4. **NON MENZIONARE** errori non inerenti a meno che l'utente non li richieda esplicitamente
5. **RISPONDERE ESCLUSIVAMENTE** alla domanda posta
6. **VIOLAZIONE = FALLIMENTO TOTALE** - Se devio dalla domanda principale sto fallendo

---

# Docker Environment Rules per osm2cai2

## Ambiente Dockerizzato
- osm2cai2 **SEMPRE** gira in un ambiente dockerizzato
- Non suggerire mai installazioni dirette di PHP, PostgreSQL, Redis o altre dipendenze sul sistema host
- Tutti i comandi devono essere eseguiti all'interno dei container Docker appropriati

## Architettura Container

### Container PHP-FPM (`phpfpm`)
- **Image**: `wm-phpfpm:8.4-fpm`
- **Container name**: `php81-${APP_NAME}` (solitamente `php81-osm2cai2`)
- **PHP Version**: 8.4-fpm
- **Working directory**: `/var/www/html/${DOCKER_PROJECT_DIR_NAME}`
- **User**: `www-data` (id: 33)
- **Porte**: 
  - `${DOCKER_PHP_PORT}:9000` (default: 9108)
  - `${DOCKER_SERVE_PORT}:8000` (default: 8008, solo locale)

### Container Database (`db`)
- **Image**: `postgis/postgis:16-3.4`
- **Container name**: `postgres-${APP_NAME}`
- **Porta**: `${DOCKER_PSQL_PORT}:5432` (default: 5508)
- **Extensions**: PostGIS attivo

### Container Redis (`redis`)
- **Image**: `redis:latest`
- **Container name**: `redis-${APP_NAME}`
- **Porta**: `6379:6379`

### Container Elasticsearch (`elasticsearch`)
- **Image**: `elasticsearch:8.11.0`
- **Container name**: `elasticsearch-${APP_NAME}`
- **Porta**: `9200:9200`

### Container MinIO (`minio`)
- **Image**: `minio/minio:latest`
- **Container name**: `minio-${APP_NAME}`
- **Porta**: `9003:9000`
- **Console**: `9004:9001`

### Container MailPit (`mailpit`)
- **Image**: `axllent/mailpit:latest`
- **Container name**: `mailpit-${APP_NAME}`
- **Porta**: `8025:8025`

## ⚠️ REGOLA CRITICA - DETERMINAZIONE NOMI CONTAINER ⚠️
**PRIMA DI USARE I NOMI DEI CONTAINER, DEVO SEMPRE DETERMINARLI AUTOMATICAMENTE**

### Procedura OBBLIGATORIA per determinare i nomi dei container:

1. **Leggere APP_NAME dal file .env**:
   ```bash
   # Se il file .env esiste, leggere APP_NAME
   if [ -f .env ]; then
       APP_NAME=$(grep "^APP_NAME=" .env | cut -d '=' -f2 | tr -d ' ' | tr -d '"' | tr -d "'")
   fi
   # Se non trovato, usare default
   APP_NAME=${APP_NAME:-osm2cai2}
   ```

2. **Verificare i container attivi** (metodo più affidabile):
   ```bash
   # Verificare container PHP
   docker ps --filter "name=php81" --format "{{.Names}}"
   
   # Verificare tutti i container del progetto
   docker ps --format "{{.Names}}" | grep -E "(php81|postgres|redis|elasticsearch|minio|mailpit)"
   ```

3. **Usare i nomi determinati** invece di hardcodare "osm2cai2"

### Pattern di Naming dei Container

### Regola Generale
Tutti i container seguono il pattern: `{SERVICE}-{APP_NAME}`

Dove:
- `{SERVICE}` = nome del servizio (php81, postgres, elasticsearch, minio, mailpit, redis)
- `{APP_NAME}` = nome dell'applicazione (leggere da .env o usare default osm2cai2)

### Mapping Servizi → Nomi Container
```bash
# Pattern: {SERVICE}-{APP_NAME}
php81-${APP_NAME}          # Container PHP
postgres-${APP_NAME}       # Container Database
redis-${APP_NAME}          # Container Redis
elasticsearch-${APP_NAME}  # Container Elasticsearch
minio-${APP_NAME}          # Container MinIO
mailpit-${APP_NAME}        # Container MailPit
```

### Esempi di Container Names (con APP_NAME=osm2cai2)
```bash
# Container PHP
php81-osm2cai2

# Container Database
postgres-osm2cai2

# Container Redis
redis-osm2cai2

# Container Elasticsearch
elasticsearch-osm2cai2

# Container MinIO
minio-osm2cai2

# Container MailPit
mailpit-osm2cai2
```

### Variabili Ambiente per Container Names
```bash
APP_NAME=osm2cai2  # LEGGERE DA .env, non hardcodare!
DOCKER_PROJECT_DIR_NAME=osm2cai2
DOCKER_PHP_PORT=9108
DOCKER_PSQL_PORT=5508
DOCKER_SERVE_PORT=8008 # solo locale
DB_HOST=db # sempre "db" (nome container)
```

### Cosa NON fare MAI:
- ❌ Hardcodare "osm2cai2" nei comandi
- ❌ Assumere che APP_NAME sia sempre "osm2cai2"
- ❌ Usare nomi di container senza verificarli

### Cosa fare SEMPRE:
- ✅ Leggere APP_NAME dal file .env prima di usarlo
- ✅ Verificare i container attivi con `docker ps`
- ✅ Usare variabili invece di valori hardcodati
- ✅ Se non trovo .env, usare default "osm2cai2" ma segnalarlo

## Comandi Essenziali

### Accesso ai Container
```bash
# Container PHP (utente www-data)
docker exec -it php81-osm2cai2 bash

# Container PHP (utente root per permessi)
docker exec -u 0 -it php81-osm2cai2 bash

# Container PostgreSQL
docker exec -it postgres-osm2cai2 bash

# Container Redis
docker exec -it redis-osm2cai2 bash

# Container Elasticsearch
docker exec -it elasticsearch-osm2cai2 bash

# Container MinIO
docker exec -it minio-osm2cai2 bash

# Container MailPit
docker exec -it mailpit-osm2cai2 bash
```

### Comandi Laravel nel Container
```bash
# Sempre nel container PHP
docker exec -it php81-osm2cai2 bash
php artisan [comando]
composer [comando]
npm [comando]
```

### Server di Sviluppo
```bash
# Nel container PHP
php artisan serve --host 0.0.0.0
# Accessibile su: http://127.0.0.1:8008
```

### Gestione Permessi
```bash
# Per problemi di permessi (come utente root)
docker exec -u 0 -it php81-osm2cai2 bash
chown -R 33 storage/
chown -R 33 bootstrap/cache/
```

## Ambiente di Sviluppo vs Produzione

### Locale (Development)
- `APP_ENV=local`
- `APP_DEBUG=true`  
- `LOG_LEVEL=debug`
- `DOCKER_SERVE_PORT` configurato (8008)
- Xdebug attivo
- Password DB semplici

### Produzione
- `APP_ENV=production`
- `APP_DEBUG=false`
- `LOG_LEVEL=warning`
- Rimuovere `DOCKER_SERVE_PORT` da docker-compose.yml
- Password DB complesse

## Tool Specifici Installati
- **osmium-tool**: per manipolazione file OSM
- **osm2pgsql**: per import dati OSM in PostgreSQL
- **gdal-bin**: per manipolazione dati geospaziali
- **postgresql-client-16**: client PostgreSQL
- **supervisor**: per gestione processi
- **nodejs/npm**: per asset frontend

## Debug con Xdebug (Solo Locale)
- Porta xdebug: 9200
- Path mapping: `/var/www/html/osm2cai2` → `${workspaceRoot}`
- Variabile ambiente: `export XDEBUG_SESSION=1`
- File log: `/var/log/xdebug.log`

## Scripts e Geobox Integration
- Utilizza il sistema **Geobox** per gestione environment
- Scripts nella cartella `scripts/` vanno eseguiti nel container PHP
- Comandi geobox disponibili:
  - `geobox_install osm2cai2`
  - `geobox_serve osm2cai2`
  - `geobox_dump_restore osm2cai2`

## ⚠️ REGOLA CRITICA - AVVIO LARAVEL SERVE E HORIZON ⚠️
**QUANDO L'UTENTE CHIEDE DI AVVIARE LARAVEL SERVE E/O HORIZON:**
- **NON MODIFICARE MAI** codice, file, script o configurazioni
- **NON CREARE MAI** file nuovi o modificare Dockerfile, docker-compose, o script
- **ESEGUIRE SOLO** i comandi direttamente nel container PHP usando `docker exec -d`
- **VIOLAZIONE = FALLIMENTO TOTALE** - Se modifico codice invece di eseguire comandi sto fallendo

### Frasi che indicano questa richiesta:
- "avvia laravel e horizon"
- "avvia serve e horizon"
- "docker avviati avvia laravel e horizon"
- "entra nel docker php e avvia laravel"
- "fai serve di laravel"
- Qualsiasi richiesta di avviare servizi Laravel nel container

### Comandi da eseguire SEMPRE (senza modificare nulla):
```bash
# 1. Determinare il nome del container PHP (leggere da .env o verificare container attivi)
# Metodo 1: Leggere APP_NAME da .env
if [ -f .env ]; then
    APP_NAME=$(grep "^APP_NAME=" .env | cut -d '=' -f2 | tr -d ' ' | tr -d '"' | tr -d "'")
fi
APP_NAME=${APP_NAME:-osm2cai2}
CONTAINER_NAME="php81-${APP_NAME}"

# Metodo 2: Verificare direttamente i container attivi (più affidabile)
CONTAINER_NAME=$(docker ps --filter "name=php81" --format "{{.Names}}" | head -n1)

# 2. Avviare Laravel serve in background
docker exec -d ${CONTAINER_NAME} php artisan serve --host=0.0.0.0

# 3. Avviare Horizon in background
docker exec -d ${CONTAINER_NAME} php artisan horizon
```

### Cosa NON fare MAI:
- ❌ Modificare Dockerfile
- ❌ Modificare docker-compose.yml
- ❌ Creare file di configurazione supervisor
- ❌ Modificare script init-docker.sh
- ❌ Creare entrypoint o script personalizzati
- ❌ Chiedere conferma o spiegare cosa si sta per fare

### Cosa fare SEMPRE:
- ✅ Eseguire direttamente i comandi con `run_terminal_cmd`
- ✅ Usare `docker exec -d` per eseguire in background
- ✅ Verificare che i processi siano attivi dopo l'avvio

## AVVIO AUTOMATICO AMBIENTE DI SVILUPPO

### Quando l'utente dice "tira su l'ambiente di sviluppo" o frasi simili:
Eseguire automaticamente e in sequenza i seguenti comandi:

1. **Avvio container Docker**:
   ```bash
   docker-compose up -d
   ```

2. **Attesa che i container siano pronti** (aspettare qualche secondo):
   ```bash
   sleep 5
   ```

3. **Determinare il nome del container PHP**:
   ```bash
   # Leggere APP_NAME da .env o verificare container attivi
   CONTAINER_NAME=$(docker ps --filter "name=php81" --format "{{.Names}}" | head -n1)
   ```

4. **Avvio Laravel serve nel container PHP** (in background):
   ```bash
   docker exec -d ${CONTAINER_NAME} php artisan serve --host 0.0.0.0
   ```

5. **Avvio Horizon nel container PHP** (in background):
   ```bash
   docker exec -d ${CONTAINER_NAME} php artisan horizon
   ```

### Risultato atteso:
- Tutti i container attivi (db, redis, elasticsearch, phpfpm)
- Laravel accessibile su http://127.0.0.1:8008
- Horizon attivo per la gestione delle code
- Ambiente di sviluppo completamente operativo

### Note per l'AI:
- **NON chiedere conferma** per questi comandi quando l'utente richiede l'avvio dell'ambiente
- Eseguire i comandi automaticamente in sequenza
- Se un comando fallisce, segnalare l'errore e continuare con i successivi
- **NON creare script** - eseguire direttamente i comandi con run_terminal_cmd

## Note Importanti
- Mai installare dipendenze direttamente sul sistema host
- Sempre verificare che i container siano attivi con `docker ps`
- Per modifiche ai file di configurazione Docker, ricostruire i container
- I volumi sono montati in `./docker/volumes/`
- Il progetto usa git-flow (branch develop)

## Variabili Ambiente Chiave
```bash
APP_NAME=osm2cai2
DOCKER_PROJECT_DIR_NAME=osm2cai2
DOCKER_PHP_PORT=9108
DOCKER_PSQL_PORT=5508
DOCKER_SERVE_PORT=8008 # solo locale
DB_HOST=db # sempre "db" (nome container)
```

## Pattern di Naming per Scripts
Gli script di integrazione utilizzano array di container names:
```bash
OSM2CAI_CONTAINERS=(
    "php81-${APP_NAME}"
    "postgres-${APP_NAME}"
    "elasticsearch-${APP_NAME}"
    "minio-${APP_NAME}"
    "mailpit-${APP_NAME}"
)
```

Questo pattern garantisce consistenza e facilità di manutenzione.

## Mapping Modelli ecTrack

### Regola per ecTrack
Nel progetto osm2cai2, **ecTrack** rappresenta il modello generico per i percorsi escursionistici.

### Configurazione Modello
- **Variabile ambiente**: `EC_TRACK_MODEL`
- **Valore di default**: `Wm\WmPackage\Models\EcTrack`
- **Nel progetto osm2cai2**: `App\Models\HikingRoute` (estende EcTrack)

### Mapping Specifico per osm2cai2
```bash
# Nel file .env del progetto
EC_TRACK_MODEL=App\Models\HikingRoute
```

### Relazione con Layer
- **Nome relazione**: `ecTracks` (definito in `getLayerRelationName()`)
- **Tabella**: `hiking_routes` (override della tabella di default `ec_tracks`)
- **Classe base**: `Wm\WmPackage\Models\EcTrack`
- **Classe specifica**: `App\Models\HikingRoute`

### Note Importanti
- Quando si fa riferimento a "ecTrack" nel codice, si intende sempre il modello configurato tramite `EC_TRACK_MODEL`
- Nel contesto di osm2cai2, ecTrack = HikingRoute
- La relazione con i layer utilizza sempre il nome `ecTracks` indipendentemente dal modello specifico
- Il modello deve estendere `Wm\WmPackage\Models\EcTrack` per mantenere la compatibilità